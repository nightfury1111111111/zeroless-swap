/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type UnsignedStruct = { rawValue: BigNumberish };

export type UnsignedStructOutput = [BigNumber] & { rawValue: BigNumber };

export type ConstructorParamsStruct = {
  expirationTimestamp: BigNumberish;
  deploymentTimestamp: BigNumberish;
  withdrawalLiveness: BigNumberish;
  collateralAddress: string;
  finderAddress: string;
  tokenFactoryAddress: string;
  timerAddress: string;
  priceFeedIdentifier: BytesLike;
  syntheticName: string;
  syntheticSymbol: string;
  strikePrice: UnsignedStruct;
  liquidationLiveness: BigNumberish;
  collateralRequirement: UnsignedStruct;
  disputeBondPct: UnsignedStruct;
  sponsorDisputeRewardPct: UnsignedStruct;
  disputerDisputeRewardPct: UnsignedStruct;
};

export type ConstructorParamsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  UnsignedStructOutput,
  BigNumber,
  UnsignedStructOutput,
  UnsignedStructOutput,
  UnsignedStructOutput,
  UnsignedStructOutput
] & {
  expirationTimestamp: BigNumber;
  deploymentTimestamp: BigNumber;
  withdrawalLiveness: BigNumber;
  collateralAddress: string;
  finderAddress: string;
  tokenFactoryAddress: string;
  timerAddress: string;
  priceFeedIdentifier: string;
  syntheticName: string;
  syntheticSymbol: string;
  strikePrice: UnsignedStructOutput;
  liquidationLiveness: BigNumber;
  collateralRequirement: UnsignedStructOutput;
  disputeBondPct: UnsignedStructOutput;
  sponsorDisputeRewardPct: UnsignedStructOutput;
  disputerDisputeRewardPct: UnsignedStructOutput;
};

export type LiquidationDataStruct = {
  sponsor: string;
  liquidator: string;
  state: BigNumberish;
  liquidationTime: BigNumberish;
  tokensOutstanding: UnsignedStruct;
  lockedCollateral: UnsignedStruct;
  rawUnitCollateral: UnsignedStruct;
  disputer: string;
  settlementPrice: UnsignedStruct;
  finalFee: UnsignedStruct;
};

export type LiquidationDataStructOutput = [
  string,
  string,
  number,
  BigNumber,
  UnsignedStructOutput,
  UnsignedStructOutput,
  UnsignedStructOutput,
  string,
  UnsignedStructOutput,
  UnsignedStructOutput
] & {
  sponsor: string;
  liquidator: string;
  state: number;
  liquidationTime: BigNumber;
  tokensOutstanding: UnsignedStructOutput;
  lockedCollateral: UnsignedStructOutput;
  rawUnitCollateral: UnsignedStructOutput;
  disputer: string;
  settlementPrice: UnsignedStructOutput;
  finalFee: UnsignedStructOutput;
};

export interface PotionInterface extends ethers.utils.Interface {
  functions: {
    "cancelTransferPosition()": FunctionFragment;
    "cancelWithdrawal()": FunctionFragment;
    "collateralCurrency()": FunctionFragment;
    "collateralRequirement()": FunctionFragment;
    "contractState()": FunctionFragment;
    "create(address,address,address,(uint256),(uint256),(uint256))": FunctionFragment;
    "createLiquidation(address,address,address,(uint256),(uint256),(uint256),(uint256))": FunctionFragment;
    "cumulativeFeeMultiplier()": FunctionFragment;
    "deploymentTimestamp()": FunctionFragment;
    "deposit((uint256))": FunctionFragment;
    "depositTo(address,(uint256))": FunctionFragment;
    "dispute(uint256,address)": FunctionFragment;
    "disputeBondPct()": FunctionFragment;
    "disputerDisputeRewardPct()": FunctionFragment;
    "emergencyShutdown()": FunctionFragment;
    "expirationTimestamp()": FunctionFragment;
    "expire()": FunctionFragment;
    "expiryPrice()": FunctionFragment;
    "finder()": FunctionFragment;
    "getCollateral(address)": FunctionFragment;
    "getCurrentTime()": FunctionFragment;
    "getDeploymentTimestamp()": FunctionFragment;
    "getLiquidations(address)": FunctionFragment;
    "liquidationLiveness()": FunctionFragment;
    "liquidations(address,uint256)": FunctionFragment;
    "payRegularFees()": FunctionFragment;
    "pfc()": FunctionFragment;
    "positions(address)": FunctionFragment;
    "priceIdentifier()": FunctionFragment;
    "rawLiquidationCollateral()": FunctionFragment;
    "rawTotalPositionCollateral()": FunctionFragment;
    "redeem((uint256))": FunctionFragment;
    "remargin()": FunctionFragment;
    "requestTransferPosition()": FunctionFragment;
    "requestWithdrawal((uint256))": FunctionFragment;
    "setCurrentTime(uint256)": FunctionFragment;
    "settleExpired()": FunctionFragment;
    "sponsorDisputeRewardPct()": FunctionFragment;
    "strikePrice()": FunctionFragment;
    "timerAddress()": FunctionFragment;
    "tokenCurrency()": FunctionFragment;
    "totalPositionCollateral()": FunctionFragment;
    "totalTokensOutstanding()": FunctionFragment;
    "transferPositionPassedRequest(address)": FunctionFragment;
    "withdraw((uint256))": FunctionFragment;
    "withdrawLiquidation(uint256,address,address)": FunctionFragment;
    "withdrawPassedRequest()": FunctionFragment;
    "withdrawalLiveness()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "cancelTransferPosition",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelWithdrawal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collateralCurrency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collateralRequirement",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "contractState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [
      string,
      string,
      string,
      UnsignedStruct,
      UnsignedStruct,
      UnsignedStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createLiquidation",
    values: [
      string,
      string,
      string,
      UnsignedStruct,
      UnsignedStruct,
      UnsignedStruct,
      UnsignedStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cumulativeFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deploymentTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [UnsignedStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "depositTo",
    values: [string, UnsignedStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "dispute",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeBondPct",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputerDisputeRewardPct",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyShutdown",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "expirationTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "expire", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "expiryPrice",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "finder", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCollateral",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDeploymentTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidations",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationLiveness",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidations",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "payRegularFees",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "pfc", values?: undefined): string;
  encodeFunctionData(functionFragment: "positions", values: [string]): string;
  encodeFunctionData(
    functionFragment: "priceIdentifier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rawLiquidationCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rawTotalPositionCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [UnsignedStruct]
  ): string;
  encodeFunctionData(functionFragment: "remargin", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "requestTransferPosition",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "requestWithdrawal",
    values: [UnsignedStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setCurrentTime",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settleExpired",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sponsorDisputeRewardPct",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "strikePrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "timerAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenCurrency",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalPositionCollateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalTokensOutstanding",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferPositionPassedRequest",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [UnsignedStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawLiquidation",
    values: [BigNumberish, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPassedRequest",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawalLiveness",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "cancelTransferPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralRequirement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contractState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cumulativeFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deploymentTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositTo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dispute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "disputeBondPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputerDisputeRewardPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emergencyShutdown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expirationTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "expire", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "expiryPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDeploymentTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationLiveness",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "payRegularFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pfc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "positions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceIdentifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rawLiquidationCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rawTotalPositionCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "remargin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "requestTransferPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestWithdrawal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCurrentTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleExpired",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sponsorDisputeRewardPct",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "strikePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timerAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalPositionCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalTokensOutstanding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferPositionPassedRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPassedRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawalLiveness",
    data: BytesLike
  ): Result;

  events: {
    "ContractExpired(address)": EventFragment;
    "Deposit(address,uint256)": EventFragment;
    "DisputeSettled(address,address,address,address,uint256,bool)": EventFragment;
    "EmergencyShutdown(address,uint256,uint256)": EventFragment;
    "EndedSponsorPosition(address)": EventFragment;
    "FinalFeesPaid(uint256)": EventFragment;
    "LiquidationCreated(address,address,uint256,uint256,uint256)": EventFragment;
    "LiquidationDisputed(address,address,address,uint256,uint256)": EventFragment;
    "LiquidationWithdrawn(address,uint256,uint8)": EventFragment;
    "NewSponsor(address)": EventFragment;
    "PositionCreated(address,uint256,uint256)": EventFragment;
    "Redeem(address,uint256,uint256)": EventFragment;
    "RegularFeesPaid(uint256,uint256)": EventFragment;
    "RequestTransferPosition(address)": EventFragment;
    "RequestTransferPositionCanceled(address)": EventFragment;
    "RequestTransferPositionExecuted(address,address)": EventFragment;
    "RequestWithdrawal(address,uint256)": EventFragment;
    "RequestWithdrawalCanceled(address,uint256)": EventFragment;
    "RequestWithdrawalExecuted(address,uint256)": EventFragment;
    "SettleExpiredPosition(address,uint256,uint256)": EventFragment;
    "Withdrawal(address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ContractExpired"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DisputeSettled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyShutdown"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EndedSponsorPosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FinalFeesPaid"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidationCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidationDisputed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidationWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewSponsor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PositionCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Redeem"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RegularFeesPaid"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestTransferPosition"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "RequestTransferPositionCanceled"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "RequestTransferPositionExecuted"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestWithdrawal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestWithdrawalCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RequestWithdrawalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SettleExpiredPosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawal"): EventFragment;
}

export type ContractExpiredEvent = TypedEvent<[string], { caller: string }>;

export type ContractExpiredEventFilter = TypedEventFilter<ContractExpiredEvent>;

export type DepositEvent = TypedEvent<
  [string, BigNumber],
  { sponsor: string; collateralAmount: BigNumber }
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export type DisputeSettledEvent = TypedEvent<
  [string, string, string, string, BigNumber, boolean],
  {
    caller: string;
    sponsor: string;
    liquidator: string;
    disputer: string;
    liquidationId: BigNumber;
    disputeSucceeded: boolean;
  }
>;

export type DisputeSettledEventFilter = TypedEventFilter<DisputeSettledEvent>;

export type EmergencyShutdownEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  {
    caller: string;
    originalExpirationTimestamp: BigNumber;
    shutdownTimestamp: BigNumber;
  }
>;

export type EmergencyShutdownEventFilter =
  TypedEventFilter<EmergencyShutdownEvent>;

export type EndedSponsorPositionEvent = TypedEvent<
  [string],
  { sponsor: string }
>;

export type EndedSponsorPositionEventFilter =
  TypedEventFilter<EndedSponsorPositionEvent>;

export type FinalFeesPaidEvent = TypedEvent<[BigNumber], { amount: BigNumber }>;

export type FinalFeesPaidEventFilter = TypedEventFilter<FinalFeesPaidEvent>;

export type LiquidationCreatedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  {
    sponsor: string;
    liquidator: string;
    liquidationId: BigNumber;
    tokensOutstanding: BigNumber;
    lockedCollateral: BigNumber;
  }
>;

export type LiquidationCreatedEventFilter =
  TypedEventFilter<LiquidationCreatedEvent>;

export type LiquidationDisputedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    sponsor: string;
    liquidator: string;
    disputer: string;
    liquidationId: BigNumber;
    disputeBondAmount: BigNumber;
  }
>;

export type LiquidationDisputedEventFilter =
  TypedEventFilter<LiquidationDisputedEvent>;

export type LiquidationWithdrawnEvent = TypedEvent<
  [string, BigNumber, number],
  { caller: string; withdrawalAmount: BigNumber; liquidationStatus: number }
>;

export type LiquidationWithdrawnEventFilter =
  TypedEventFilter<LiquidationWithdrawnEvent>;

export type NewSponsorEvent = TypedEvent<[string], { sponsor: string }>;

export type NewSponsorEventFilter = TypedEventFilter<NewSponsorEvent>;

export type PositionCreatedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { sponsor: string; collateralAmount: BigNumber; tokenAmount: BigNumber }
>;

export type PositionCreatedEventFilter = TypedEventFilter<PositionCreatedEvent>;

export type RedeemEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { sponsor: string; collateralAmount: BigNumber; tokenAmount: BigNumber }
>;

export type RedeemEventFilter = TypedEventFilter<RedeemEvent>;

export type RegularFeesPaidEvent = TypedEvent<
  [BigNumber, BigNumber],
  { regularFee: BigNumber; lateFee: BigNumber }
>;

export type RegularFeesPaidEventFilter = TypedEventFilter<RegularFeesPaidEvent>;

export type RequestTransferPositionEvent = TypedEvent<
  [string],
  { oldSponsor: string }
>;

export type RequestTransferPositionEventFilter =
  TypedEventFilter<RequestTransferPositionEvent>;

export type RequestTransferPositionCanceledEvent = TypedEvent<
  [string],
  { oldSponsor: string }
>;

export type RequestTransferPositionCanceledEventFilter =
  TypedEventFilter<RequestTransferPositionCanceledEvent>;

export type RequestTransferPositionExecutedEvent = TypedEvent<
  [string, string],
  { oldSponsor: string; newSponsor: string }
>;

export type RequestTransferPositionExecutedEventFilter =
  TypedEventFilter<RequestTransferPositionExecutedEvent>;

export type RequestWithdrawalEvent = TypedEvent<
  [string, BigNumber],
  { sponsor: string; collateralAmount: BigNumber }
>;

export type RequestWithdrawalEventFilter =
  TypedEventFilter<RequestWithdrawalEvent>;

export type RequestWithdrawalCanceledEvent = TypedEvent<
  [string, BigNumber],
  { sponsor: string; collateralAmount: BigNumber }
>;

export type RequestWithdrawalCanceledEventFilter =
  TypedEventFilter<RequestWithdrawalCanceledEvent>;

export type RequestWithdrawalExecutedEvent = TypedEvent<
  [string, BigNumber],
  { sponsor: string; collateralAmount: BigNumber }
>;

export type RequestWithdrawalExecutedEventFilter =
  TypedEventFilter<RequestWithdrawalExecutedEvent>;

export type SettleExpiredPositionEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { caller: string; collateralReturned: BigNumber; tokensBurned: BigNumber }
>;

export type SettleExpiredPositionEventFilter =
  TypedEventFilter<SettleExpiredPositionEvent>;

export type WithdrawalEvent = TypedEvent<
  [string, BigNumber],
  { sponsor: string; collateralAmount: BigNumber }
>;

export type WithdrawalEventFilter = TypedEventFilter<WithdrawalEvent>;

export interface Potion extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PotionInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Cancels a pending transfer position request.
     */
    cancelTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancels a pending withdrawal request.
     */
    cancelWithdrawal(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    collateralCurrency(overrides?: CallOverrides): Promise<[string]>;

    collateralRequirement(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    contractState(overrides?: CallOverrides): Promise<[number]>;

    create(
      poolAddress: string,
      buyerAddress: string,
      empCreator: string,
      numTokens: UnsignedStruct,
      premiumDeposit: UnsignedStruct,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createLiquidation(
      sponsor: string,
      liquidator: string,
      empCreator: string,
      maxTokensToLiquidate: UnsignedStruct,
      assetPrice: UnsignedStruct,
      finalFeeBond: UnsignedStruct,
      excessDeposit: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cumulativeFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    deploymentTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    deposit(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    depositTo(
      sponsor: string,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
     * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
     * @param liquidationId of the disputed liquidation.
     * @param sponsor the address of the sponsor whose liquidation is being disputed.
     */
    dispute(
      liquidationId: BigNumberish,
      sponsor: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    disputeBondPct(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    disputerDisputeRewardPct(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    /**
     * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` which prevents re-entry into this function or the `expire` function. No fees are paid when calling `emergencyShutdown` as the governor who would call the function would also receive the fees.
     * Premature contract settlement under emergency circumstances.
     */
    emergencyShutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    expirationTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * this function can only be called once the contract is expired and can't be re-called.
     * Locks contract state in expired and requests oracle price.
     */
    expire(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    expiryPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    finder(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
     * Accessor method for a sponsor's collateral.
     * @param sponsor address whose collateral amount is retrieved.
     */
    getCollateral(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<
      [UnsignedStructOutput] & { collateralAmount: UnsignedStructOutput }
    >;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDeploymentTimestamp(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { deployTime: BigNumber }>;

    /**
     * Gets all liquidation information for a given sponsor address.
     * @param sponsor address of the position sponsor.
     */
    getLiquidations(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<
      [LiquidationDataStructOutput[]] & {
        liquidationData: LiquidationDataStructOutput[];
      }
    >;

    liquidationLiveness(overrides?: CallOverrides): Promise<[BigNumber]>;

    liquidations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        number,
        BigNumber,
        UnsignedStructOutput,
        UnsignedStructOutput,
        UnsignedStructOutput,
        string,
        UnsignedStructOutput,
        UnsignedStructOutput
      ] & {
        sponsor: string;
        liquidator: string;
        state: number;
        liquidationTime: BigNumber;
        tokensOutstanding: UnsignedStructOutput;
        lockedCollateral: UnsignedStructOutput;
        rawUnitCollateral: UnsignedStructOutput;
        disputer: string;
        settlementPrice: UnsignedStructOutput;
        finalFee: UnsignedStructOutput;
      }
    >;

    /**
     * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
     * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
     */
    payRegularFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
     * Gets the current profit from corruption for this contract in terms of the collateral currency.
     */
    pfc(overrides?: CallOverrides): Promise<[UnsignedStructOutput]>;

    positions(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [
        UnsignedStructOutput,
        BigNumber,
        UnsignedStructOutput,
        UnsignedStructOutput,
        BigNumber
      ] & {
        tokensOutstanding: UnsignedStructOutput;
        withdrawalRequestPassTimestamp: BigNumber;
        withdrawalRequestAmount: UnsignedStructOutput;
        rawCollateral: UnsignedStructOutput;
        transferPositionRequestPassTimestamp: BigNumber;
      }
    >;

    priceIdentifier(overrides?: CallOverrides): Promise<[string]>;

    rawLiquidationCollateral(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    rawTotalPositionCollateral(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    redeem(
      numTokens: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
     * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
     */
    remargin(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The liveness length is the same as the withdrawal liveness.
     * Requests to transfer ownership of the caller's current position to a new sponsor address. Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.
     */
    requestTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    requestWithdrawal(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(
      time: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.
     * After a contract has passed expiry all token holders can redeem their tokens for underlying at the prevailing price defined by the DVM from the `expire` function.
     */
    settleExpired(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sponsorDisputeRewardPct(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    strikePrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    timerAddress(overrides?: CallOverrides): Promise<[string]>;

    tokenCurrency(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Accessor method for the total collateral stored within the PricelessPositionManager.
     */
    totalPositionCollateral(
      overrides?: CallOverrides
    ): Promise<
      [UnsignedStructOutput] & { totalCollateral: UnsignedStructOutput }
    >;

    totalTokensOutstanding(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rawValue: BigNumber }>;

    /**
     * Transferring positions can only occur if the recipient does not already have a position.
     * After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.
     * @param newSponsorAddress is the address to which the position will be transferred.
     */
    transferPositionPassedRequest(
      newSponsorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawLiquidation(
      liquidationId: BigNumberish,
      sponsor: string,
      caller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
     * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
     */
    withdrawPassedRequest(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawalLiveness(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  /**
   * Cancels a pending transfer position request.
   */
  cancelTransferPosition(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancels a pending withdrawal request.
   */
  cancelWithdrawal(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  collateralCurrency(overrides?: CallOverrides): Promise<string>;

  collateralRequirement(overrides?: CallOverrides): Promise<BigNumber>;

  contractState(overrides?: CallOverrides): Promise<number>;

  create(
    poolAddress: string,
    buyerAddress: string,
    empCreator: string,
    numTokens: UnsignedStruct,
    premiumDeposit: UnsignedStruct,
    collateralAmount: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createLiquidation(
    sponsor: string,
    liquidator: string,
    empCreator: string,
    maxTokensToLiquidate: UnsignedStruct,
    assetPrice: UnsignedStruct,
    finalFeeBond: UnsignedStruct,
    excessDeposit: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cumulativeFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  deposit(
    collateralAmount: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  depositTo(
    sponsor: string,
    collateralAmount: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
   * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
   * @param liquidationId of the disputed liquidation.
   * @param sponsor the address of the sponsor whose liquidation is being disputed.
   */
  dispute(
    liquidationId: BigNumberish,
    sponsor: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  disputeBondPct(overrides?: CallOverrides): Promise<BigNumber>;

  disputerDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` which prevents re-entry into this function or the `expire` function. No fees are paid when calling `emergencyShutdown` as the governor who would call the function would also receive the fees.
   * Premature contract settlement under emergency circumstances.
   */
  emergencyShutdown(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  expirationTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * this function can only be called once the contract is expired and can't be re-called.
   * Locks contract state in expired and requests oracle price.
   */
  expire(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  expiryPrice(overrides?: CallOverrides): Promise<BigNumber>;

  finder(overrides?: CallOverrides): Promise<string>;

  /**
   * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
   * Accessor method for a sponsor's collateral.
   * @param sponsor address whose collateral amount is retrieved.
   */
  getCollateral(
    sponsor: string,
    overrides?: CallOverrides
  ): Promise<UnsignedStructOutput>;

  /**
   * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
   */
  getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

  getDeploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Gets all liquidation information for a given sponsor address.
   * @param sponsor address of the position sponsor.
   */
  getLiquidations(
    sponsor: string,
    overrides?: CallOverrides
  ): Promise<LiquidationDataStructOutput[]>;

  liquidationLiveness(overrides?: CallOverrides): Promise<BigNumber>;

  liquidations(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      number,
      BigNumber,
      UnsignedStructOutput,
      UnsignedStructOutput,
      UnsignedStructOutput,
      string,
      UnsignedStructOutput,
      UnsignedStructOutput
    ] & {
      sponsor: string;
      liquidator: string;
      state: number;
      liquidationTime: BigNumber;
      tokensOutstanding: UnsignedStructOutput;
      lockedCollateral: UnsignedStructOutput;
      rawUnitCollateral: UnsignedStructOutput;
      disputer: string;
      settlementPrice: UnsignedStructOutput;
      finalFee: UnsignedStructOutput;
    }
  >;

  /**
   * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
   * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
   */
  payRegularFees(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
   * Gets the current profit from corruption for this contract in terms of the collateral currency.
   */
  pfc(overrides?: CallOverrides): Promise<UnsignedStructOutput>;

  positions(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [
      UnsignedStructOutput,
      BigNumber,
      UnsignedStructOutput,
      UnsignedStructOutput,
      BigNumber
    ] & {
      tokensOutstanding: UnsignedStructOutput;
      withdrawalRequestPassTimestamp: BigNumber;
      withdrawalRequestAmount: UnsignedStructOutput;
      rawCollateral: UnsignedStructOutput;
      transferPositionRequestPassTimestamp: BigNumber;
    }
  >;

  priceIdentifier(overrides?: CallOverrides): Promise<string>;

  rawLiquidationCollateral(overrides?: CallOverrides): Promise<BigNumber>;

  rawTotalPositionCollateral(overrides?: CallOverrides): Promise<BigNumber>;

  redeem(
    numTokens: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
   * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
   */
  remargin(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The liveness length is the same as the withdrawal liveness.
   * Requests to transfer ownership of the caller's current position to a new sponsor address. Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.
   */
  requestTransferPosition(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  requestWithdrawal(
    collateralAmount: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Will revert if not running in test mode.
   * Sets the current time.
   * @param time timestamp to set current Testable time to.
   */
  setCurrentTime(
    time: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.
   * After a contract has passed expiry all token holders can redeem their tokens for underlying at the prevailing price defined by the DVM from the `expire` function.
   */
  settleExpired(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sponsorDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

  strikePrice(overrides?: CallOverrides): Promise<BigNumber>;

  timerAddress(overrides?: CallOverrides): Promise<string>;

  tokenCurrency(overrides?: CallOverrides): Promise<string>;

  /**
   * Accessor method for the total collateral stored within the PricelessPositionManager.
   */
  totalPositionCollateral(
    overrides?: CallOverrides
  ): Promise<UnsignedStructOutput>;

  totalTokensOutstanding(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Transferring positions can only occur if the recipient does not already have a position.
   * After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.
   * @param newSponsorAddress is the address to which the position will be transferred.
   */
  transferPositionPassedRequest(
    newSponsorAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    collateralAmount: UnsignedStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawLiquidation(
    liquidationId: BigNumberish,
    sponsor: string,
    caller: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
   * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
   */
  withdrawPassedRequest(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawalLiveness(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    /**
     * Cancels a pending transfer position request.
     */
    cancelTransferPosition(overrides?: CallOverrides): Promise<void>;

    /**
     * Cancels a pending withdrawal request.
     */
    cancelWithdrawal(overrides?: CallOverrides): Promise<void>;

    collateralCurrency(overrides?: CallOverrides): Promise<string>;

    collateralRequirement(overrides?: CallOverrides): Promise<BigNumber>;

    contractState(overrides?: CallOverrides): Promise<number>;

    create(
      poolAddress: string,
      buyerAddress: string,
      empCreator: string,
      numTokens: UnsignedStruct,
      premiumDeposit: UnsignedStruct,
      collateralAmount: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    createLiquidation(
      sponsor: string,
      liquidator: string,
      empCreator: string,
      maxTokensToLiquidate: UnsignedStruct,
      assetPrice: UnsignedStruct,
      finalFeeBond: UnsignedStruct,
      excessDeposit: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cumulativeFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      collateralAmount: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    depositTo(
      sponsor: string,
      collateralAmount: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
     * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
     * @param liquidationId of the disputed liquidation.
     * @param sponsor the address of the sponsor whose liquidation is being disputed.
     */
    dispute(
      liquidationId: BigNumberish,
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    disputeBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    disputerDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` which prevents re-entry into this function or the `expire` function. No fees are paid when calling `emergencyShutdown` as the governor who would call the function would also receive the fees.
     * Premature contract settlement under emergency circumstances.
     */
    emergencyShutdown(overrides?: CallOverrides): Promise<void>;

    expirationTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function can only be called once the contract is expired and can't be re-called.
     * Locks contract state in expired and requests oracle price.
     */
    expire(overrides?: CallOverrides): Promise<void>;

    expiryPrice(overrides?: CallOverrides): Promise<BigNumber>;

    finder(overrides?: CallOverrides): Promise<string>;

    /**
     * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
     * Accessor method for a sponsor's collateral.
     * @param sponsor address whose collateral amount is retrieved.
     */
    getCollateral(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getDeploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets all liquidation information for a given sponsor address.
     * @param sponsor address of the position sponsor.
     */
    getLiquidations(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<LiquidationDataStructOutput[]>;

    liquidationLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    liquidations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        number,
        BigNumber,
        UnsignedStructOutput,
        UnsignedStructOutput,
        UnsignedStructOutput,
        string,
        UnsignedStructOutput,
        UnsignedStructOutput
      ] & {
        sponsor: string;
        liquidator: string;
        state: number;
        liquidationTime: BigNumber;
        tokensOutstanding: UnsignedStructOutput;
        lockedCollateral: UnsignedStructOutput;
        rawUnitCollateral: UnsignedStructOutput;
        disputer: string;
        settlementPrice: UnsignedStructOutput;
        finalFee: UnsignedStructOutput;
      }
    >;

    /**
     * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
     * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
     */
    payRegularFees(overrides?: CallOverrides): Promise<UnsignedStructOutput>;

    /**
     * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
     * Gets the current profit from corruption for this contract in terms of the collateral currency.
     */
    pfc(overrides?: CallOverrides): Promise<UnsignedStructOutput>;

    positions(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [
        UnsignedStructOutput,
        BigNumber,
        UnsignedStructOutput,
        UnsignedStructOutput,
        BigNumber
      ] & {
        tokensOutstanding: UnsignedStructOutput;
        withdrawalRequestPassTimestamp: BigNumber;
        withdrawalRequestAmount: UnsignedStructOutput;
        rawCollateral: UnsignedStructOutput;
        transferPositionRequestPassTimestamp: BigNumber;
      }
    >;

    priceIdentifier(overrides?: CallOverrides): Promise<string>;

    rawLiquidationCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    rawTotalPositionCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    redeem(
      numTokens: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    /**
     * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
     * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
     */
    remargin(overrides?: CallOverrides): Promise<void>;

    /**
     * The liveness length is the same as the withdrawal liveness.
     * Requests to transfer ownership of the caller's current position to a new sponsor address. Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.
     */
    requestTransferPosition(overrides?: CallOverrides): Promise<void>;

    requestWithdrawal(
      collateralAmount: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.
     * After a contract has passed expiry all token holders can redeem their tokens for underlying at the prevailing price defined by the DVM from the `expire` function.
     */
    settleExpired(overrides?: CallOverrides): Promise<UnsignedStructOutput>;

    sponsorDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

    strikePrice(overrides?: CallOverrides): Promise<BigNumber>;

    timerAddress(overrides?: CallOverrides): Promise<string>;

    tokenCurrency(overrides?: CallOverrides): Promise<string>;

    /**
     * Accessor method for the total collateral stored within the PricelessPositionManager.
     */
    totalPositionCollateral(
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    totalTokensOutstanding(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transferring positions can only occur if the recipient does not already have a position.
     * After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.
     * @param newSponsorAddress is the address to which the position will be transferred.
     */
    transferPositionPassedRequest(
      newSponsorAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      collateralAmount: UnsignedStruct,
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    withdrawLiquidation(
      liquidationId: BigNumberish,
      sponsor: string,
      caller: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
     * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
     */
    withdrawPassedRequest(
      overrides?: CallOverrides
    ): Promise<UnsignedStructOutput>;

    withdrawalLiveness(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "ContractExpired(address)"(
      caller?: string | null
    ): ContractExpiredEventFilter;
    ContractExpired(caller?: string | null): ContractExpiredEventFilter;

    "Deposit(address,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): DepositEventFilter;
    Deposit(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): DepositEventFilter;

    "DisputeSettled(address,address,address,address,uint256,bool)"(
      caller?: string | null,
      sponsor?: string | null,
      liquidator?: string | null,
      disputer?: null,
      liquidationId?: null,
      disputeSucceeded?: null
    ): DisputeSettledEventFilter;
    DisputeSettled(
      caller?: string | null,
      sponsor?: string | null,
      liquidator?: string | null,
      disputer?: null,
      liquidationId?: null,
      disputeSucceeded?: null
    ): DisputeSettledEventFilter;

    "EmergencyShutdown(address,uint256,uint256)"(
      caller?: string | null,
      originalExpirationTimestamp?: null,
      shutdownTimestamp?: null
    ): EmergencyShutdownEventFilter;
    EmergencyShutdown(
      caller?: string | null,
      originalExpirationTimestamp?: null,
      shutdownTimestamp?: null
    ): EmergencyShutdownEventFilter;

    "EndedSponsorPosition(address)"(
      sponsor?: string | null
    ): EndedSponsorPositionEventFilter;
    EndedSponsorPosition(
      sponsor?: string | null
    ): EndedSponsorPositionEventFilter;

    "FinalFeesPaid(uint256)"(
      amount?: BigNumberish | null
    ): FinalFeesPaidEventFilter;
    FinalFeesPaid(amount?: BigNumberish | null): FinalFeesPaidEventFilter;

    "LiquidationCreated(address,address,uint256,uint256,uint256)"(
      sponsor?: string | null,
      liquidator?: string | null,
      liquidationId?: BigNumberish | null,
      tokensOutstanding?: null,
      lockedCollateral?: null
    ): LiquidationCreatedEventFilter;
    LiquidationCreated(
      sponsor?: string | null,
      liquidator?: string | null,
      liquidationId?: BigNumberish | null,
      tokensOutstanding?: null,
      lockedCollateral?: null
    ): LiquidationCreatedEventFilter;

    "LiquidationDisputed(address,address,address,uint256,uint256)"(
      sponsor?: string | null,
      liquidator?: string | null,
      disputer?: string | null,
      liquidationId?: null,
      disputeBondAmount?: null
    ): LiquidationDisputedEventFilter;
    LiquidationDisputed(
      sponsor?: string | null,
      liquidator?: string | null,
      disputer?: string | null,
      liquidationId?: null,
      disputeBondAmount?: null
    ): LiquidationDisputedEventFilter;

    "LiquidationWithdrawn(address,uint256,uint8)"(
      caller?: string | null,
      withdrawalAmount?: null,
      liquidationStatus?: BigNumberish | null
    ): LiquidationWithdrawnEventFilter;
    LiquidationWithdrawn(
      caller?: string | null,
      withdrawalAmount?: null,
      liquidationStatus?: BigNumberish | null
    ): LiquidationWithdrawnEventFilter;

    "NewSponsor(address)"(sponsor?: string | null): NewSponsorEventFilter;
    NewSponsor(sponsor?: string | null): NewSponsorEventFilter;

    "PositionCreated(address,uint256,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null,
      tokenAmount?: BigNumberish | null
    ): PositionCreatedEventFilter;
    PositionCreated(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null,
      tokenAmount?: BigNumberish | null
    ): PositionCreatedEventFilter;

    "Redeem(address,uint256,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null,
      tokenAmount?: BigNumberish | null
    ): RedeemEventFilter;
    Redeem(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null,
      tokenAmount?: BigNumberish | null
    ): RedeemEventFilter;

    "RegularFeesPaid(uint256,uint256)"(
      regularFee?: BigNumberish | null,
      lateFee?: BigNumberish | null
    ): RegularFeesPaidEventFilter;
    RegularFeesPaid(
      regularFee?: BigNumberish | null,
      lateFee?: BigNumberish | null
    ): RegularFeesPaidEventFilter;

    "RequestTransferPosition(address)"(
      oldSponsor?: string | null
    ): RequestTransferPositionEventFilter;
    RequestTransferPosition(
      oldSponsor?: string | null
    ): RequestTransferPositionEventFilter;

    "RequestTransferPositionCanceled(address)"(
      oldSponsor?: string | null
    ): RequestTransferPositionCanceledEventFilter;
    RequestTransferPositionCanceled(
      oldSponsor?: string | null
    ): RequestTransferPositionCanceledEventFilter;

    "RequestTransferPositionExecuted(address,address)"(
      oldSponsor?: string | null,
      newSponsor?: string | null
    ): RequestTransferPositionExecutedEventFilter;
    RequestTransferPositionExecuted(
      oldSponsor?: string | null,
      newSponsor?: string | null
    ): RequestTransferPositionExecutedEventFilter;

    "RequestWithdrawal(address,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalEventFilter;
    RequestWithdrawal(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalEventFilter;

    "RequestWithdrawalCanceled(address,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalCanceledEventFilter;
    RequestWithdrawalCanceled(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalCanceledEventFilter;

    "RequestWithdrawalExecuted(address,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalExecutedEventFilter;
    RequestWithdrawalExecuted(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): RequestWithdrawalExecutedEventFilter;

    "SettleExpiredPosition(address,uint256,uint256)"(
      caller?: string | null,
      collateralReturned?: BigNumberish | null,
      tokensBurned?: BigNumberish | null
    ): SettleExpiredPositionEventFilter;
    SettleExpiredPosition(
      caller?: string | null,
      collateralReturned?: BigNumberish | null,
      tokensBurned?: BigNumberish | null
    ): SettleExpiredPositionEventFilter;

    "Withdrawal(address,uint256)"(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): WithdrawalEventFilter;
    Withdrawal(
      sponsor?: string | null,
      collateralAmount?: BigNumberish | null
    ): WithdrawalEventFilter;
  };

  estimateGas: {
    /**
     * Cancels a pending transfer position request.
     */
    cancelTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Cancels a pending withdrawal request.
     */
    cancelWithdrawal(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    collateralCurrency(overrides?: CallOverrides): Promise<BigNumber>;

    collateralRequirement(overrides?: CallOverrides): Promise<BigNumber>;

    contractState(overrides?: CallOverrides): Promise<BigNumber>;

    create(
      poolAddress: string,
      buyerAddress: string,
      empCreator: string,
      numTokens: UnsignedStruct,
      premiumDeposit: UnsignedStruct,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createLiquidation(
      sponsor: string,
      liquidator: string,
      empCreator: string,
      maxTokensToLiquidate: UnsignedStruct,
      assetPrice: UnsignedStruct,
      finalFeeBond: UnsignedStruct,
      excessDeposit: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cumulativeFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    deploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    depositTo(
      sponsor: string,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
     * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
     * @param liquidationId of the disputed liquidation.
     * @param sponsor the address of the sponsor whose liquidation is being disputed.
     */
    dispute(
      liquidationId: BigNumberish,
      sponsor: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    disputeBondPct(overrides?: CallOverrides): Promise<BigNumber>;

    disputerDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` which prevents re-entry into this function or the `expire` function. No fees are paid when calling `emergencyShutdown` as the governor who would call the function would also receive the fees.
     * Premature contract settlement under emergency circumstances.
     */
    emergencyShutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    expirationTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function can only be called once the contract is expired and can't be re-called.
     * Locks contract state in expired and requests oracle price.
     */
    expire(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    expiryPrice(overrides?: CallOverrides): Promise<BigNumber>;

    finder(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
     * Accessor method for a sponsor's collateral.
     * @param sponsor address whose collateral amount is retrieved.
     */
    getCollateral(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getDeploymentTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Gets all liquidation information for a given sponsor address.
     * @param sponsor address of the position sponsor.
     */
    getLiquidations(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    liquidations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
     * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
     */
    payRegularFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
     * Gets the current profit from corruption for this contract in terms of the collateral currency.
     */
    pfc(overrides?: CallOverrides): Promise<BigNumber>;

    positions(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    priceIdentifier(overrides?: CallOverrides): Promise<BigNumber>;

    rawLiquidationCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    rawTotalPositionCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    redeem(
      numTokens: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
     * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
     */
    remargin(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The liveness length is the same as the withdrawal liveness.
     * Requests to transfer ownership of the caller's current position to a new sponsor address. Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.
     */
    requestTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    requestWithdrawal(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(
      time: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.
     * After a contract has passed expiry all token holders can redeem their tokens for underlying at the prevailing price defined by the DVM from the `expire` function.
     */
    settleExpired(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sponsorDisputeRewardPct(overrides?: CallOverrides): Promise<BigNumber>;

    strikePrice(overrides?: CallOverrides): Promise<BigNumber>;

    timerAddress(overrides?: CallOverrides): Promise<BigNumber>;

    tokenCurrency(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Accessor method for the total collateral stored within the PricelessPositionManager.
     */
    totalPositionCollateral(overrides?: CallOverrides): Promise<BigNumber>;

    totalTokensOutstanding(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transferring positions can only occur if the recipient does not already have a position.
     * After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.
     * @param newSponsorAddress is the address to which the position will be transferred.
     */
    transferPositionPassedRequest(
      newSponsorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdraw(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawLiquidation(
      liquidationId: BigNumberish,
      sponsor: string,
      caller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
     * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
     */
    withdrawPassedRequest(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawalLiveness(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Cancels a pending transfer position request.
     */
    cancelTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancels a pending withdrawal request.
     */
    cancelWithdrawal(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    collateralCurrency(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    collateralRequirement(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contractState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    create(
      poolAddress: string,
      buyerAddress: string,
      empCreator: string,
      numTokens: UnsignedStruct,
      premiumDeposit: UnsignedStruct,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createLiquidation(
      sponsor: string,
      liquidator: string,
      empCreator: string,
      maxTokensToLiquidate: UnsignedStruct,
      assetPrice: UnsignedStruct,
      finalFeeBond: UnsignedStruct,
      excessDeposit: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cumulativeFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deploymentTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deposit(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    depositTo(
      sponsor: string,
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.
     * Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final fee charged on each price request.
     * @param liquidationId of the disputed liquidation.
     * @param sponsor the address of the sponsor whose liquidation is being disputed.
     */
    dispute(
      liquidationId: BigNumberish,
      sponsor: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    disputeBondPct(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    disputerDisputeRewardPct(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` which prevents re-entry into this function or the `expire` function. No fees are paid when calling `emergencyShutdown` as the governor who would call the function would also receive the fees.
     * Premature contract settlement under emergency circumstances.
     */
    emergencyShutdown(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    expirationTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function can only be called once the contract is expired and can't be re-called.
     * Locks contract state in expired and requests oracle price.
     */
    expire(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    expiryPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    finder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This is necessary because the struct returned by the positions() method shows rawCollateral, which isn't a user-readable value.
     * Accessor method for a sponsor's collateral.
     * @param sponsor address whose collateral amount is retrieved.
     */
    getCollateral(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. Otherwise, it will return the block timestamp.
     */
    getCurrentTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeploymentTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets all liquidation information for a given sponsor address.
     * @param sponsor address of the position sponsor.
     */
    getLiquidations(
      sponsor: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidationLiveness(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidations(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * These must be paid periodically for the life of the contract. If the contract has not paid its regular fee in a week or more then a late penalty is applied which is sent to the caller. If the amount of fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. An event is only fired if the fees charged are greater than 0.
     * Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.
     */
    payRegularFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.
     * Gets the current profit from corruption for this contract in terms of the collateral currency.
     */
    pfc(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    positions(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    priceIdentifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rawLiquidationCollateral(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rawTotalPositionCollateral(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    redeem(
      numTokens: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.
     * Theoretically supposed to pay fees and move money between margin accounts to make sure they reflect the NAV of the contract. However, this functionality doesn't apply to this contract.
     */
    remargin(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The liveness length is the same as the withdrawal liveness.
     * Requests to transfer ownership of the caller's current position to a new sponsor address. Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.
     */
    requestTransferPosition(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    requestWithdrawal(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Will revert if not running in test mode.
     * Sets the current time.
     * @param time timestamp to set current Testable time to.
     */
    setCurrentTime(
      time: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.
     * After a contract has passed expiry all token holders can redeem their tokens for underlying at the prevailing price defined by the DVM from the `expire` function.
     */
    settleExpired(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sponsorDisputeRewardPct(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    strikePrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timerAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenCurrency(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Accessor method for the total collateral stored within the PricelessPositionManager.
     */
    totalPositionCollateral(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalTokensOutstanding(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transferring positions can only occur if the recipient does not already have a position.
     * After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.
     * @param newSponsorAddress is the address to which the position will be transferred.
     */
    transferPositionPassedRequest(
      newSponsorAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      collateralAmount: UnsignedStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawLiquidation(
      liquidationId: BigNumberish,
      sponsor: string,
      caller: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Might not withdraw the full requested amount in order to account for precision loss or if the full requested amount exceeds the collateral in the position (due to paying fees).
     * After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.
     */
    withdrawPassedRequest(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawalLiveness(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
